
//=============================================================================
//	@file	Font.h
//	@brief	フォント
//	@autor	Takuya Ochi
//	@date	2018/12/30
//=============================================================================

//-----------------------------------------------------------------------------
//	@brief	コンストラクタ
//-----------------------------------------------------------------------------
#include "Font.h"

//-----------------------------------------------------------------------------
// @brief  コンストラクタ
//-----------------------------------------------------------------------------
Font::Font()
{
	m_widht = 0;
	m_height = 0;

	for (int i = 0; i < CommonConstant::FONT_NUM; i++)
	{
		m_textMap[i] = -1;
		m_textImg[i] = 0;
	}
}

//-----------------------------------------------------------------------------
// @brief  デストラクタ
//-----------------------------------------------------------------------------
Font::~Font()
{
	//処理なし
}

//-----------------------------------------------------------------------------
// @brief  インスタンス生成
//-----------------------------------------------------------------------------
Font* Font::GetInstance()
{
	return &s_instance;
}

//-----------------------------------------------------------------------------
// @brief  作成処理
//-----------------------------------------------------------------------------
void Font::Create()
{
	//画像のセット
	_SetGraph(10, 1, "Data/Sprite/Score/Score.png");

	//画像と文字の連結
	_ReMap("0123456789");
}

//-----------------------------------------------------------------------------
// @brief  描画処理
//-----------------------------------------------------------------------------
void Font::Draw(int x, int y, char* string)
{
	//引数の値がいじられないように仮変数
	int tmpX = x;
	int tmpY = y;
	int index;

	//入力された文字分回す
	while (*string)
	{
		//もし、改行文字だったら
		if (*string == '\n')
		{
			//ｘは初期値へ、ｙは１文字分下へ
			tmpX = x;
			tmpY += m_height;

			//文字列を次へ
			string++;

			//以下の処理は実行しない
			continue;
		}

		//画像の添え字を代入
		index = m_textMap[*string];

		//１文字分の画像の描画
		if (index >= 0)
		{
			DrawGraph(tmpX, tmpY, m_textImg[index], TRUE);
		}

		//ｘは１文字分右へ
		tmpX += m_widht;

		//文字列を次へ
		string++;
	}
}

//-----------------------------------------------------------------------------
// @brief  画像のセット
//-----------------------------------------------------------------------------
void Font::_SetGraph(int _xNum, int _yNum, const char* _fileName)
{
	//画像の大きさを取るための仮変数
	int tmpImg;
	int tmpWidht;
	int tmpHeight;

	//一旦、画像自体の幅と高さの大きさを取り、画像データを消す
	tmpImg = LoadGraph(_fileName);
	GetGraphSize(tmpImg, &tmpWidht, &tmpHeight);
	DeleteGraph(tmpImg);

	//画像の大きさから文字の個数で割ることで、１文字の大きさを取る
	m_widht = tmpWidht / _xNum;
	m_height = tmpHeight / _yNum;

	//１文字分の大きさをもとに画像の分割読み込み
	LoadDivGraph(_fileName, _xNum * _yNum, _xNum, _yNum, m_widht, m_height, m_textImg);
}

//-----------------------------------------------------------------------------
// @brief  画像と文字の連結
//-----------------------------------------------------------------------------
void Font::_ReMap(const char* _reMap)
{
	//仮の変数
	const char* tmpReMap = _reMap;
	char tmpNum = 0;

	//画像と文字の連結
	while (*tmpReMap && tmpNum < CommonConstant::FONT_NUM)
	{
		m_textMap[*tmpReMap++] = tmpNum++;
	}
}